<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JLPT N1 AI 문제 생성기</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <meta name="theme-color" content="#3B82F6">
    <meta name="description" content="Claude AI가 실시간으로 새로운 JLPT N1 문제를 생성합니다">

    <!-- 파비콘 설정 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🇯🇵</text></svg>">

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;
        const { createRoot } = ReactDOM;

        // 로딩 아이콘 컴포넌트
        const LoaderIcon = () => (
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        );

        const JLPTGenerator = () => {
            const [currentProblem, setCurrentProblem] = useState(null);
            const [selectedType, setSelectedType] = useState('random');
            const [showAnswer, setShowAnswer] = useState(false);
            const [score, setScore] = useState({ correct: 0, total: 0 });
            const [isGenerating, setIsGenerating] = useState(false);
            const [generationHistory, setGenerationHistory] = useState([]);
            const [apiStatus, setApiStatus] = useState('확인 중...');

            // 백업용 로컬 문제 데이터
            const backupProblems = {
                kanji: [
                    {
                        question: "이 지역은**豊穣**한 토지로 알려져 있다.",
                        underlined: "豊穣",
                        choices: ["ほうじょう", "ほうろう", "ぽうじょう", "ぼうじょう"],
                        correct: 0,
                        explanation: "豊穣（ほうじょう）= 풍요로운, 비옥한",
                        source: "로컬"
                    },
                    {
                        question: "그의**洞察力**에는 놀랐다.",
                        underlined: "洞察力", 
                        choices: ["どうさつりょく", "とうさつりょく", "どうせつりょく", "とうせつりょく"],
                        correct: 0,
                        explanation: "洞察力（どうさつりょく）= 통찰력",
                        source: "로컬"
                    },
                    {
                        question: "이**機器**의 성능은 뛰어나다.",
                        underlined: "機器",
                        choices: ["きき", "きが", "きけ", "きぎ"],
                        correct: 0,
                        explanation: "機器（きき）= 기기, 기계",
                        source: "로컬"
                    }
                ],
                grammar: [
                    {
                        question: "그는 바쁜（　）매일 공부를 계속하고 있다.",
                        choices: ["にもかかわらず", "によって", "において", "に対して"],
                        correct: 0,
                        explanation: "にもかかわらず = ~에도 불구하고",
                        source: "로컬"
                    },
                    {
                        question: "이 계획은 비용（　）문제가 있다.",
                        choices: ["にとって", "の点で", "として", "によって"],
                        correct: 1,
                        explanation: "~の点で = ~의 면에서, ~에 관해서",
                        source: "로컬"
                    },
                    {
                        question: "그의 의견은 참고（　）한다.",
                        choices: ["にすぎない", "になる", "にする", "にはならない"],
                        correct: 1,
                        explanation: "参考になる = 참고가 되다",
                        source: "로컬"
                    }
                ],
                vocabulary: [
                    {
                        question: "새로운 시스템의（　）을 위해 연수를 실시한다.",
                        choices: ["浸透", "沈殿", "浸水", "沈没"],
                        correct: 0,
                        explanation: "浸透（しんとう）= 침투, 보급",
                        source: "로컬"
                    },
                    {
                        question: "이 문제의（　）을 명확히 할 필요가 있다.",
                        choices: ["要因", "要員", "用人", "要人"],
                        correct: 0,
                        explanation: "要因（よういん）= 요인, 원인",
                        source: "로컬"
                    },
                    {
                        question: "환경 보호에 대한（　）이 높아지고 있다.",
                        choices: ["関心", "感心", "歓심", "観心"],
                        correct: 0,
                        explanation: "関心（かんしん）= 관심",
                        source: "로컬"
                    }
                ],
                reading: [
                    {
                        passage: "현대 사회에서 기술 혁신의 속도는 가속도적으로 증가하고 있다. 특히 AI 기술의 발달로 인해 종래 인간이 수행하던 업무의 많은 부분이 자동화되고 있다. 이러한 변화는 효율성의 향상을 가져오는 한편, 고용 문제라는 새로운 과제를 낳고 있다.",
                        question: "이 문장의 주요한 테마는 무엇인가?",
                        choices: ["AI 기술의 역사", "기술 혁신에 의한 변화와 그 영향", "고용 문제의 해결책", "효율성 향상의 방법"],
                        correct: 1,
                        explanation: "기술 혁신이 가져오는 변화와 그 영향에 대해 논하고 있음",
                        source: "로컬"
                    },
                    {
                        passage: "지속 가능한 발전을 위해서는 환경 보호와 경제 성장의 양립이 필수적이다. 하지만 이는 매우 어려운 과제이며, 많은 국가들이 이 문제로 고민하고 있다. 최근 들어 친환경 기술의 발달로 인해 해결의 실마리가 보이기 시작했다.",
                        question: "이 글에서 언급되지 않은 것은?",
                        choices: ["환경과 경제의 양립의 어려움", "친환경 기술의 발달", "교육 제도의 개혁", "지속 가능한 발전의 중요성"],
                        correct: 2,
                        explanation: "교육 제도의 개혁에 대한 언급은 없음",
                        source: "로컬"
                    }
                ]
            };

            // 템플릿 기반 문제 생성 데이터
            const problemTemplates = {
                kanji: {
                    templates: [
                        { sentence: "이 {context}는 {adjective}로 알려져 있다.", contexts: ["지역", "기술", "방법", "기업", "제도"], adjectives: ["豊穣", "革新的", "효果적", "선진적", "획기적"] },
                        { sentence: "그의 {skill}에는 {feeling}다.", skills: ["기능", "능력", "재능", "실력", "수완"], feelings: ["감탄", "감심", "경복", "칭찬", "감동"] },
                        { sentence: "이 {object}의 {quality}는 {level}다.", objects: ["제품", "서비스", "기술", "시스템", "방법"], qualities: ["품질", "성능", "정도", "효율", "안전성"], levels: ["뛰어나", "우수하", "훌륭하", "탁월하", "완벽하"] }
                    ],
                    words: [
                        { word: "豊穣", reading: "ほうじょう", wrongReadings: ["ほうろう", "ぽうじょう", "ぼうじょう"], meaning: "풍요로운, 비옥한" },
                        { word: "洞察力", reading: "どうさつりょく", wrongReadings: ["とうさつりょく", "どうせつりょく", "とうせつりょく"], meaning: "통찰력" },
                        { word: "革新的", reading: "かくしんてき", wrongReadings: ["かくじんてき", "かくしてき", "がくしんてき"], meaning: "혁신적인" },
                        { word: "顕著", reading: "けんちょ", wrongReadings: ["けんしょ", "げんちょ", "げんしょ"], meaning: "현저한, 뚜렷한" },
                        { word: "潜在", reading: "せんざい", wrongReadings: ["せんたい", "ぜんざい", "ぜんたい"], meaning: "잠재적인" },
                        { word: "慢性", reading: "まんせい", wrongReadings: ["ばんせい", "まんしょう", "ばんしょう"], meaning: "만성적인" }
                    ]
                }
            };

            // 클라우드 API 상태 확인
            const checkAPIStatus = async () => {
                try {
                    // 실제 백엔드가 없으므로 시뮬레이션
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    setApiStatus('❌ 백엔드 API 없음 (템플릿 모드)');
                } catch (error) {
                    setApiStatus('❌ API 연결 실패');
                }
            };




            useEffect(() => {
                checkAPIStatus();
            }, []);

            // 템플릿 기반 문제 생성
            const generateWithTemplate = async (problemType) => {
                setIsGenerating(true);
                try {
                    // 로딩 시뮬레이션
                    await new Promise(resolve => setTimeout(resolve, 1500));

                    let generatedProblem;


                    if (problemType === 'kanji') {
                        const targetWord = problemTemplates.kanji.words[Math.floor(Math.random() * problemTemplates.kanji.words.length)];
                        const template = problemTemplates.kanji.templates[Math.floor(Math.random() * problemTemplates.kanji.templates.length)];
                        const context = template.contexts[Math.floor(Math.random() * template.contexts.length)];
                        
                        let sentence = template.sentence.replace('{context}', context).replace('{adjective}', targetWord.word);
                        const allChoices = [targetWord.reading, ...targetWord.wrongReadings].sort(() => Math.random() - 0.5);
                        
                        generatedProblem = {
                            question: sentence.replace(targetWord.word, `**${targetWord.word}**`),
                            underlined: targetWord.word,
                            choices: allChoices,
                            correct: allChoices.indexOf(targetWord.reading),
                            explanation: `${targetWord.word}（${targetWord.reading}）= ${targetWord.meaning}`,
                            type: 'kanji'
                        };





                    } else {
                        // 다른 타입들은 백업 문제에서 랜덤 선택
                        const backupList = backupProblems[problemType];
                        const randomProblem = backupList[Math.floor(Math.random() * backupList.length)];
                        generatedProblem = { ...randomProblem, type: problemType };
                    }

                    const problemWithMeta = {
                        ...generatedProblem,
                        id: Date.now(),
                        source: "템플릿 생성",
                        generatedAt: new Date().toLocaleString()
                    };

                    setGenerationHistory(prev => [problemWithMeta, ...prev.slice(0, 9)]);
                    return problemWithMeta;

                } catch (error) {
                    console.error("템플릿 문제 생성 실패:", error);


                    // 최종 백업
                    const backupList = backupProblems[problemType];
                    const randomBackup = backupList[Math.floor(Math.random() * backupList.length)];

                    return {
                        ...randomBackup,
                        type: problemType,
                        id: Date.now(),
                        source: "로컬 백업",
                        error: "템플릿 생성 실패로 백업 문제를 사용합니다."
                    };
                } finally {
                    setIsGenerating(false);
                }
            };















































            // 문제 생성 메인 함수
            const generateProblem = async () => {
                let problemType = selectedType;
                if (problemType === 'random') {
                    const types = ['kanji', 'grammar', 'vocabulary', 'reading'];
                    problemType = types[Math.floor(Math.random() * types.length)];
                }

                const newProblem = await generateWithCompleteAPI(problemType);
                setCurrentProblem(newProblem);
                setShowAnswer(false);
            };

            // 답안 처리
            const handleAnswer = (selectedIndex) => {
                if (currentProblem && selectedIndex === currentProblem.correct) {
                    setScore(prev => ({ correct: prev.correct + 1, total: prev.total + 1 }));
                } else {
                    setScore(prev => ({ ...prev, total: prev.total + 1 }));
                }
                setShowAnswer(true);
            };

            // 답안 스타일링
            const getButtonStyle = (index) => {
                if (!showAnswer) {
                    return "bg-white hover:bg-blue-50 border border-gray-300 text-gray-700";
                }

                if (index === currentProblem.correct) {
                    return "bg-green-100 border-green-500 text-green-800";
                } else {
                    return "bg-red-100 border-red-300 text-red-700";
                }
            };

            return (
                <div className="max-w-4xl mx-auto p-6 bg-white min-h-screen">
                    {/* 헤더 */}
                    <div className="text-center mb-8">
                        <h1 className="text-3xl font-bold text-gray-800 mb-2">🇯🇵 JLPT N1 AI 문제 생성기</h1>
                        <p className="text-gray-600">AI가 실시간으로 새로운 N1 문제를 생성합니다!</p>
                    </div>

                    {/* 상태 표시 */}
                    <div className="grid md:grid-cols-3 gap-4 mb-6">
                        <div className="bg-blue-50 p-4 rounded-lg text-center">
                            <div className="text-lg font-semibold text-blue-800">
                                정답률: {score.total > 0 ? Math.round((score.correct / score.total) * 100) : 0}% 
                                ({score.correct}/{score.total})
                            </div>
                        </div>
                        <div className="bg-green-50 p-4 rounded-lg text-center">
                            <div className="text-lg font-semibold text-green-800">
                                생성된 문제: {generationHistory.length}개
                            </div>
                        </div>
                        <div className="bg-purple-50 p-4 rounded-lg text-center">
                            <div className="text-sm font-semibold text-purple-800">
                                {apiStatus}
                            </div>
                        </div>
                    </div>

                    {/* 문제 유형 선택 */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold mb-3">문제 유형 선택</h3>
                        <div className="flex flex-wrap gap-2">
                            {[
                                { value: 'random', label: '🎲 랜덤' },
                                { value: 'kanji', label: '漢 한자 읽기' },
                                { value: 'grammar', label: '📝 문법' },
                                { value: 'vocabulary', label: '📚 어휘' },
                                { value: 'reading', label: '📖 독해' }
                            ].map((type) => (
                                <button
                                    key={type.value}
                                    onClick={() => setSelectedType(type.value)}
                                    className={`px-4 py-2 rounded-lg transition-colors ${
                                        selectedType === type.value
                                            ? 'bg-blue-500 text-white'
                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                    }`}
                                >
                                    {type.label}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* 문제 생성 버튼 */}
                    <div className="text-center mb-8">
                        <button
                            onClick={generateProblem}
                            disabled={isGenerating}
                            className="bg-green-500 hover:bg-green-600 disabled:bg-gray-400 text-white px-8 py-3 rounded-lg text-lg font-semibold transition-colors flex items-center gap-2 mx-auto"
                        >
                            {isGenerating ? (
                                <>
                                    <LoaderIcon />
                                    AI가 문제 생성 중...
                                </>
                            ) : (
                                <>
                                    🚀 새 문제 생성
                                </>
                            )}
                        </button>
                        {isGenerating && (
                            <p className="text-sm text-gray-600 mt-2">
                                맞춤형 N1 문제를 생성하고 있습니다. 잠시만 기다려주세요...
                            </p>
                        )}
                    </div>

                    {/* 문제 표시 */}
                    {currentProblem && (
                        <div className="bg-gray-50 p-6 rounded-lg mb-6">
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="text-xl font-semibold">
                                    {currentProblem.type === 'kanji' ? '한자 읽기' : 
                                     currentProblem.type === 'grammar' ? '문법' :
                                     currentProblem.type === 'vocabulary' ? '어휘' : '독해'} 문제
                                </h3>
                                <div className="text-sm text-gray-500">
                                    {currentProblem.source} | {currentProblem.generatedAt}
                                </div>
                            </div>

                            {currentProblem.error && (
                                <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded text-yellow-800">
                                    ⚠️ {currentProblem.error}
                                </div>
                            )}







                            {/* 독해 지문 */}
                            {currentProblem.type === 'reading' && (
                                <div className="mb-6 p-4 bg-white rounded border">
                                    <p className="text-gray-800 leading-relaxed text-lg">{currentProblem.passage}</p>
                                </div>
                            )}

                            {/* 문제 */}
                            <div className="mb-6">
                                <p className="text-lg mb-4">
                                    {currentProblem.type === 'kanji' ? (
                                        <>
                                            다음 문장의 밑줄 친 부분의 읽기로 가장 적절한 것을 고르시오.<br />
                                            <span className="font-bold text-xl mt-2 block">
                                                {currentProblem.question?.replace('**' + currentProblem.underlined + '**', 
                                                    `<u>${currentProblem.underlined}</u>`).replace(/<u>|<\/u>/g, (match) => match === '<u>' ? '__' : '__')}
                                            </span>
                                        </>
                                    ) : currentProblem.type === 'reading' ? (
                                        <span className="font-bold">{currentProblem.question}</span>
                                    ) : (
                                        <>
                                            다음 문장의 (　)에 들어갈 가장 적절한 것을 고르시오.<br />
                                            <span className="font-bold text-xl mt-2 block">{currentProblem.question}</span>
                                        </>
                                    )}
                                </p>
                            </div>

                            {/* 선택지 */}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4">
                                {currentProblem.choices?.map((choice, index) => (
                                    <button
                                        key={index}
                                        onClick={() => handleAnswer(index)}
                                        disabled={showAnswer}
                                        className={`p-4 rounded-lg text-left transition-colors ${getButtonStyle(index)}`}
                                    >
                                        <span className="font-semibold mr-2">{index + 1}.</span>
                                        {choice}
                                    </button>
                                ))}
                            </div>

                            {/* 정답 및 해설 */}
                            {showAnswer && (
                                <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                                    <h4 className="font-semibold text-blue-800 mb-2">정답 및 해설</h4>
                                    <p className="text-blue-700">
                                        <span className="font-bold">정답:</span> {currentProblem.correct + 1}번 - {currentProblem.choices[currentProblem.correct]}
                                    </p>
                                    <p className="text-blue-700 mt-2">
                                        <span className="font-bold">해설:</span> {currentProblem.explanation}
                                    </p>
                                </div>
                            )}
                        </div>
                    )}

                    {/* 최근 생성 이력 */}
                    {generationHistory.length > 0 && (
                        <div className="mt-8">
                            <h3 className="text-lg font-semibold mb-3">최근 생성된 문제들</h3>
                            <div className="grid md:grid-cols-2 gap-3">
                                {generationHistory.slice(0, 4).map((problem) => (
                                    <div key={problem.id} className="bg-gray-100 p-3 rounded text-sm">
                                        <div className="flex justify-between items-center mb-1">
                                            <span className="font-semibold">
                                                {problem.type === 'kanji' ? '한자' : 
                                                 problem.type === 'grammar' ? '문법' :
                                                 problem.type === 'vocabulary' ? '어휘' : '독해'}
                                            </span>
                                            <span className="text-gray-500">{problem.source}</span>
                                        </div>
                                        <p className="text-gray-700 truncate">
                                            {problem.question?.substring(0, 50)}...
                                        </p>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* 푸터 */}
                    <div className="mt-12 text-center text-gray-500 text-sm">
                        <p>JLPT N1 대비용 문제 생성기</p>
                        <p>실제 시험과는 다를 수 있으니 참고용으로만 사용해주세요.</p>
                    </div>
                </div>
            );
        };

        // React 18 방식으로 앱 렌더링
        const root = createRoot(document.getElementById('root'));
        root.render(<JLPTGenerator />);
    </script>
</body>
</html>
