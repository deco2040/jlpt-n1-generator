<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JLPT N1 AI ë¬¸ì œ ìƒì„±ê¸°</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3B82F6">
    <link rel="apple-touch-icon" href="icon-192.png">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState } = React;

        const JLPTGenerator = () => {
            const [currentProblem, setCurrentProblem] = useState(null);
            const [selectedType, setSelectedType] = useState('random');
            const [showAnswer, setShowAnswer] = useState(false);
            const [score, setScore] = useState({ correct: 0, total: 0 });
            const [isGenerating, setIsGenerating] = useState(false);
            const [generationHistory, setGenerationHistory] = useState([]);

            // ë°±ì—…ìš© ë¡œì»¬ ë¬¸ì œ (ìµœì¢… ë°±ì—…)
            const backupProblems = {
                kanji: [
                    {
                        question: "ã“ã®åœ°åŸŸã¯**è±Šç©£**ãªåœŸåœ°ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚",
                        underlined: "è±Šç©£",
                        choices: ["ã»ã†ã˜ã‚‡ã†", "ã»ã†ã‚ã†", "ã½ã†ã˜ã‚‡ã†", "ã¼ã†ã˜ã‚‡ã†"],
                        correct: 0,
                        explanation: "è±Šç©£ï¼ˆã»ã†ã˜ã‚‡ã†ï¼‰= í’ìš”ë¡œìš´, ë¹„ì˜¥í•œ",
                        source: "ë¡œì»¬"
                    },
                    {
                        question: "å½¼ã®**æ´å¯ŸåŠ›**ã«ã¯é©šã‹ã•ã‚Œã‚‹ã€‚",
                        underlined: "æ´å¯ŸåŠ›",
                        choices: ["ã©ã†ã•ã¤ã‚Šã‚‡ã", "ã¨ã†ã•ã¤ã‚Šã‚‡ã", "ã©ã†ã›ã¤ã‚Šã‚‡ã", "ã¨ã†ã›ã¤ã‚Šã‚‡ã"],
                        correct: 0,
                        explanation: "æ´å¯ŸåŠ›ï¼ˆã©ã†ã•ã¤ã‚Šã‚‡ãï¼‰= í†µì°°ë ¥",
                        source: "ë¡œì»¬"
                    }
                ],
                grammar: [
                    {
                        question: "å½¼ã¯å¿™ã—ã„ï¼ˆã€€ï¼‰ã€æ¯æ—¥å‹‰å¼·ã‚’ç¶šã‘ã¦ã„ã‚‹ã€‚",
                        choices: ["ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš", "ã«ã‚ˆã£ã¦", "ã«ãŠã„ã¦", "ã«å¯¾ã—ã¦"],
                        correct: 0,
                        explanation: "ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš = ~ì—ë„ ë¶ˆêµ¬í•˜ê³ ",
                        source: "ë¡œì»¬"
                    },
                    {
                        question: "ã“ã®è¨ˆç”»ã¯è²»ç”¨ï¼ˆã€€ï¼‰å•é¡ŒãŒã‚ã‚‹ã€‚",
                        choices: ["ã«ã¨ã£ã¦", "ã®ç‚¹ã§", "ã¨ã—ã¦", "ã«ã‚ˆã£ã¦"],
                        correct: 1,
                        explanation: "~ã®ç‚¹ã§ = ~ì˜ ë©´ì—ì„œ, ~ì— ê´€í•´ì„œ",
                        source: "ë¡œì»¬"
                    }
                ],
                vocabulary: [
                    {
                        question: "æ–°ã—ã„ã‚·ã‚¹ãƒ†ãƒ ã®ï¼ˆã€€ï¼‰ã‚’å›³ã‚‹ãŸã‚ã€ç ”ä¿®ã‚’è¡Œã†ã€‚",
                        choices: ["æµ¸é€", "æ²ˆæ®¿", "æµ¸æ°´", "æ²ˆæ²¡"],
                        correct: 0,
                        explanation: "æµ¸é€ï¼ˆã—ã‚“ã¨ã†ï¼‰= ì¹¨íˆ¬, ë³´ê¸‰",
                        source: "ë¡œì»¬"
                    },
                    {
                        question: "ã“ã®å•é¡Œã®ï¼ˆã€€ï¼‰ã‚’æ˜ã‚‰ã‹ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚",
                        choices: ["è¦å› ", "è¦å“¡", "ç”¨äºº", "è¦äºº"],
                        correct: 0,
                        explanation: "è¦å› ï¼ˆã‚ˆã†ã„ã‚“ï¼‰= ìš”ì¸, ì›ì¸",
                        source: "ë¡œì»¬"
                    }
                ],
                reading: [
                    {
                        passage: "ç¾ä»£ç¤¾ä¼šã«ãŠã‘ã‚‹æŠ€è¡“é©æ–°ã®é€Ÿåº¦ã¯åŠ é€Ÿåº¦çš„ã«å¢—ã—ã¦ã„ã‚‹ã€‚ç‰¹ã«AIæŠ€è¡“ã®ç™ºé”ã«ã‚ˆã‚Šã€å¾“æ¥äººé–“ãŒè¡Œã£ã¦ã„ãŸæ¥­å‹™ã®å¤šããŒè‡ªå‹•åŒ–ã•ã‚Œã¤ã¤ã‚ã‚‹ã€‚",
                        question: "ã“ã®æ–‡ç« ã®ä¸»è¦ãªãƒ†ãƒ¼ãƒã¯ä½•ã‹ã€‚",
                        choices: ["AIæŠ€è¡“ã®æ­´å²ã«ã¤ã„ã¦", "æŠ€è¡“é©æ–°ã«ã‚ˆã‚‹å¤‰åŒ–ã¨ãã®å½±éŸ¿", "é›‡ìš©å•é¡Œã®è§£æ±ºì±…", "íš¨ìœ¨ì„±å‘ìƒã®æ–¹æ³•"],
                        correct: 1,
                        explanation: "ê¸°ìˆ í˜ì‹ ì´ ê°€ì ¸ì˜¤ëŠ” ë³€í™”ì™€ ê·¸ ì˜í–¥ì— ëŒ€í•´ ë…¼í•˜ê³  ìˆìŒ",
                        source: "ë¡œì»¬"
                    }
                ]
            };

            // ë°±ì—”ë“œ API í˜¸ì¶œë¡œ ìƒˆ ë¬¸ì œ ìƒì„± (1ìˆœìœ„)
            const generateWithAPI = async (problemType) => {
                setIsGenerating(true);
                
                try {
                    const response = await fetch('/api/generate-problem', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ problemType })
                    });

                    if (!response.ok) {
                        throw new Error(`API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    const problemWithMeta = {
                        ...data.problem,
                        id: Date.now(),
                        generatedAt: new Date().toLocaleString()
                    };

                    setGenerationHistory(prev => [problemWithMeta, ...prev.slice(0, 9)]);
                    return problemWithMeta;

                } catch (error) {
                    console.error("ë°±ì—”ë“œ API í˜¸ì¶œ ì‹¤íŒ¨:", error);
                    
                    // API ì‹¤íŒ¨ ì‹œ í…œí”Œë¦¿ ì‹œìŠ¤í…œìœ¼ë¡œ ëŒ€ì²´
                    return await generateWithTemplate(problemType);
                } finally {
                    setIsGenerating(false);
                }
            };

            // í…œí”Œë¦¿ ê¸°ë°˜ ë¬¸ì œ ìƒì„± (2ìˆœìœ„ ë°±ì—…)
            const generateWithTemplate = async (problemType) => {
                // í…œí”Œë¦¿ ê¸°ë°˜ ë¬¸ì œ ë°ì´í„°
                const problemTemplates = {
                    kanji: {
                        templates: [
                            { sentence: "ã“ã®{context}ã¯{adjective}ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚", contexts: ["åœ°åŸŸ", "æŠ€è¡“", "æ–¹æ³•", "ä¼æ¥­", "åˆ¶åº¦"], adjectives: ["è±Šç©£", "é©æ–°çš„", "åŠ¹ç‡çš„", "å…ˆé€²çš„", "ç”»æœŸçš„"] },
                            { sentence: "å½¼ã®{skill}ã«ã¯{feeling}ã€‚", contexts: ["æŠ€èƒ½", "èƒ½åŠ›", "æ‰èƒ½", "å®ŸåŠ›", "æ‰‹è…•"], adjectives: ["é©šå˜†", "æ„Ÿå¿ƒ", "æ•¬æœ", "ç§°è³›", "æ„Ÿå‹•"] },
                            { sentence: "ã“ã®{object}ã®{quality}ã¯{level}ã ã€‚", contexts: ["è£½å“", "ã‚µãƒ¼ãƒ“ã‚¹", "æŠ€è¡“", "ã‚·ã‚¹ãƒ†ãƒ ", "æ–¹æ³•"], adjectives: ["å“è³ª", "æ€§èƒ½", "ç²¾åº¦", "åŠ¹ç‡", "å®‰å…¨æ€§"] }
                        ],
                        words: [
                            { word: "è±Šç©£", reading: "ã»ã†ã˜ã‚‡ã†", wrongReadings: ["ã»ã†ã‚ã†", "ã½ã†ã˜ã‚‡ã†", "ã¼ã†ã˜ã‚‡ã†"], meaning: "í’ìš”ë¡œìš´, ë¹„ì˜¥í•œ" },
                            { word: "æ´å¯ŸåŠ›", reading: "ã©ã†ã•ã¤ã‚Šã‚‡ã", wrongReadings: ["ã¨ã†ã•ã¤ã‚Šã‚‡ã", "ã©ã†ã›ã¤ã‚Šã‚‡ã", "ã¨ã†ã›ã¤ã‚Šã‚‡ã"], meaning: "í†µì°°ë ¥" },
                            { word: "æ ¹æœ¬çš„", reading: "ã“ã‚“ã½ã‚“ã¦ã", wrongReadings: ["ã­ã‚‚ã¨ã¦ã", "ã“ã‚“ã‚‚ã¨ã¦ã", "ã­ã»ã‚“ã¦ã"], meaning: "ê·¼ë³¸ì ì¸" },
                            { word: "ç”»æœŸçš„", reading: "ã‹ã£ãã¦ã", wrongReadings: ["ãŒãã¦ã", "ãŒã£ãã¦ã", "ã‹ãã¦ã"], meaning: "íšê¸°ì ì¸" },
                            { word: "ä½è¿·", reading: "ã¦ã„ã‚ã„", wrongReadings: ["ã¦ã„ã¾ã„", "ã¦ã„ã³", "ã¦ã„ã„"], meaning: "ì¹¨ì²´, ë¶€ì§„" },
                            { word: "é¡•è‘—", reading: "ã‘ã‚“ã¡ã‚‡", wrongReadings: ["ã‘ã‚“ã—ã‚‡", "ã’ã‚“ã¡ã‚‡", "ã’ã‚“ã—ã‚‡"], meaning: "í˜„ì €í•œ, ëšœë ·í•œ" },
                            { word: "æ½œåœ¨", reading: "ã›ã‚“ã–ã„", wrongReadings: ["ã›ã‚“ãŸã„", "ãœã‚“ã–ã„", "ãœã‚“ãŸã„"], meaning: "ì ì¬ì ì¸" },
                            { word: "æ…¢æ€§", reading: "ã¾ã‚“ã›ã„", wrongReadings: ["ã°ã‚“ã›ã„", "ã¾ã‚“ã—ã‚‡ã†", "ã°ã‚“ã—ã‚‡ã†"], meaning: "ë§Œì„±ì ì¸" }
                        ]
                    },
                    grammar: [
                        { pattern: "ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš", meaning: "~ì—ë„ ë¶ˆêµ¬í•˜ê³ ", examples: ["é›¨", "å¿™ã—ã„", "åå¯¾", "å›°é›£"], contexts: ["è©¦åˆã¯è¡Œã‚ã‚ŒãŸ", "å‹‰å¼·ã‚’ç¶šã‘ãŸ", "è¨ˆç”»ã‚’å®Ÿè¡Œã—ãŸ", "æˆåŠŸã—ãŸ"] },
                        { pattern: "ã®ã‚ã‚Šã«", meaning: "~ì— ë¹„í•´, ~ì¹˜ê³ ëŠ”", examples: ["è‹¥ã„", "å®‰ã„", "ç°¡å˜", "çŸ­æ™‚é–“"], contexts: ["ã—ã£ã‹ã‚Šã—ã¦ã„ã‚‹", "å“è³ªãŒè‰¯ã„", "é›£ã—ãæ„Ÿã˜ã‚‹", "å¤šãã®ã“ã¨ã‚’å­¦ã‚“ã "] },
                        { pattern: "ã«åŸºã¥ã„ã¦", meaning: "~ì— ê¸°ì´ˆí•˜ì—¬", examples: ["äº‹å®Ÿ", "ãƒ‡ãƒ¼ã‚¿", "çµŒé¨“", "ç†è«–"], contexts: ["åˆ¤æ–­ã™ã‚‹", "è¨ˆç”»ã‚’ç«‹ã¦ã‚‹", "æ±ºå®šã™ã‚‹", "åˆ†æã™ã‚‹"] },
                        { pattern: "ã‚’é™ã‚Šã«", meaning: "~ì„ ë§ˆì§€ë§‰ìœ¼ë¡œ", examples: ["ä»Šæ—¥", "ä»Šå¹´", "ã“ã®ä»•äº‹", "ä»Šå›"], contexts: ["è¾ã‚ã‚‹", "çµ‚äº†ã™ã‚‹", "å¼•é€€ã™ã‚‹", "æœ€å¾Œã«ã™ã‚‹"] },
                        { pattern: "ã®ç‚¹ã§", meaning: "~ì˜ ë©´ì—ì„œ", examples: ["å®‰å…¨æ€§", "åŠ¹ç‡", "ã‚³ã‚¹ãƒˆ", "å“è³ª"], contexts: ["å•é¡ŒãŒã‚ã‚‹", "å„ªã‚Œã¦ã„ã‚‹", "æ”¹å–„ãŒå¿…è¦", "æº€è¶³ã—ã¦ã„ã‚‹"] },
                        { pattern: "ã«éš›ã—ã¦", meaning: "~ì— ì¦ˆìŒí•˜ì—¬", examples: ["å’æ¥­", "é–‹æ¥­", "çµå©š", "è»¢è·"], contexts: ["æŒ¨æ‹¶ã‚’ã™ã‚‹", "æº–å‚™ã‚’ã™ã‚‹", "ç¥ç¦ã‚’å—ã‘ã‚‹", "æ±ºæ„ã‚’æ–°ãŸã«ã™ã‚‹"] }
                    ],
                    vocabulary: [
                        { word: "æµ¸é€", wrongWords: ["æ²ˆæ®¿", "æµ¸æ°´", "æ²ˆæ²¡"], meaning: "ì¹¨íˆ¬, ë³´ê¸‰", contexts: ["æ–°ã—ã„ã‚·ã‚¹ãƒ†ãƒ ã®{word}ã‚’å›³ã‚‹ãŸã‚ã€ç ”ä¿®ã‚’è¡Œã†ã€‚"] },
                        { word: "è¦å› ", wrongWords: ["è¦å“¡", "ç”¨äºº", "è¦äºº"], meaning: "ìš”ì¸, ì›ì¸", contexts: ["ã“ã®å•é¡Œã®{word}ã‚’æ˜ã‚‰ã‹ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚"] },
                        { word: "æ¤œè¨", wrongWords: ["è¦‹å½“", "å¥é—˜", "æ¤œç–«"], meaning: "ê²€í† ", contexts: ["å½¼ã®ææ¡ˆã¯{word}ã«å€¤ã™ã‚‹ã€‚"] },
                        { word: "ç²¾åº¦", wrongWords: ["æ­£ç¢ºåº¦", "ç²¾å¯†åº¦", "æ¸…åº¦"], meaning: "ì •ë°€ë„", contexts: ["ã“ã®æŠ€è¡“ã®{word}ã«ã¯é©šã„ãŸã€‚"] },
                        { word: "é–¢å¿ƒ", wrongWords: ["è¦³å¿ƒ", "æ„Ÿå¿ƒ", "æ­“å¿ƒ"], meaning: "ê´€ì‹¬", contexts: ["ç’°å¢ƒå•é¡Œã¸ã®{word}ãŒé«˜ã¾ã£ã¦ã„ã‚‹ã€‚"] },
                        { word: "ä¿ƒé€²", wrongWords: ["å³é€²", "è¶³é€²", "å´é€²"], meaning: "ì´‰ì§„", contexts: ["çµŒæ¸ˆç™ºå±•ã®{word}ãŒæ€¥å‹™ã ã€‚"] },
                        { word: "æ‡¸å¿µ", wrongWords: ["çœŒå¿µ", "è³¢å¿µ", "å …å¿µ"], meaning: "ìš°ë ¤", contexts: ["å®‰å…¨æ€§ã¸ã®{word}ãŒé«˜ã¾ã£ã¦ã„ã‚‹ã€‚"] }
                    ]
                };

                try {
                    await new Promise(resolve => setTimeout(resolve, 800)); // ë¡œë”© íš¨ê³¼

                    let generatedProblem;

                    if (problemType === 'kanji') {
                        const template = problemTemplates.kanji.templates[Math.floor(Math.random() * problemTemplates.kanji.templates.length)];
                        const targetWord = problemTemplates.kanji.words[Math.floor(Math.random() * problemTemplates.kanji.words.length)];
                        const context = template.contexts[Math.floor(Math.random() * template.contexts.length)];
                        const adjective = template.adjectives[Math.floor(Math.random() * template.adjectives.length)];
                        
                        let sentence = template.sentence.replace('{context}', context).replace('{adjective}', adjective);
                        sentence = sentence.replace(adjective, targetWord.word);
                        
                        const allChoices = [targetWord.reading, ...targetWord.wrongReadings].sort(() => Math.random() - 0.5);
                        
                        generatedProblem = {
                            question: sentence.replace(targetWord.word, `**${targetWord.word}**`),
                            underlined: targetWord.word,
                            choices: allChoices,
                            correct: allChoices.indexOf(targetWord.reading),
                            explanation: `${targetWord.word}ï¼ˆ${targetWord.reading}ï¼‰= ${targetWord.meaning}`
                        };
                    } else if (problemType === 'grammar') {
                        const grammarItem = problemTemplates.grammar[Math.floor(Math.random() * problemTemplates.grammar.length)];
                        const example = grammarItem.examples[Math.floor(Math.random() * grammarItem.examples.length)];
                        const context = grammarItem.contexts[Math.floor(Math.random() * grammarItem.contexts.length)];
                        
                        const wrongPatterns = problemTemplates.grammar
                            .filter(g => g.pattern !== grammarItem.pattern)
                            .map(g => g.pattern)
                            .slice(0, 3);
                        
                        const allChoices = [grammarItem.pattern, ...wrongPatterns].sort(() => Math.random() - 0.5);
                        
                        generatedProblem = {
                            question: `${example}ï¼ˆã€€ï¼‰ã€${context}ã€‚`,
                            choices: allChoices,
                            correct: allChoices.indexOf(grammarItem.pattern),
                            explanation: `${grammarItem.pattern} = ${grammarItem.meaning}`
                        };
                    } else if (problemType === 'vocabulary') {
                        const vocabItem = problemTemplates.vocabulary[Math.floor(Math.random() * problemTemplates.vocabulary.length)];
                        const context = vocabItem.contexts[Math.floor(Math.random() * vocabItem.contexts.length)];
                        const allChoices = [vocabItem.word, ...vocabItem.wrongWords].sort(() => Math.random() - 0.5);
                        
                        generatedProblem = {
                            question: context.replace('{word}', 'ï¼ˆã€€ï¼‰'),
                            choices: allChoices,
                            correct: allChoices.indexOf(vocabItem.word),
                            explanation: `${vocabItem.word} = ${vocabItem.meaning}`
                        };
                    } else { // reading
                        const passages = [
                            {
                                text: "ç¾ä»£ç¤¾ä¼šã«ãŠã„ã¦ã€æŒç¶šå¯èƒ½ãªç™ºå±•ãŒé‡è¦è¦–ã•ã‚Œã¦ã„ã‚‹ã€‚ç’°å¢ƒä¿è­·ã¨çµŒæ¸ˆæˆé•·ã®ä¸¡ç«‹ã¯å›°é›£ãªèª²é¡Œã ãŒã€æŠ€è¡“é©æ–°ã«ã‚ˆã‚Šè§£æ±ºã®ç³¸å£ãŒè¦‹ãˆã¦ããŸã€‚",
                                question: "ã“ã®æ–‡ç« ã§è¿°ã¹ã‚‰ã‚Œã¦ã„ã‚‹ä¸»ãªå†…å®¹ã¯ä½•ã‹ã€‚",
                                choices: ["ç’°å¢ƒä¿è­·ã®é‡è¦æ€§", "æŒç¶šå¯èƒ½ãªç™ºå±•ã®èª²é¡Œã¨å¯èƒ½æ€§", "æŠ€è¡“é©æ–°ã®é™ç•Œ", "ê²½ì œæˆé•·ì˜ ë¬¸ì œì "],
                                correct: 1
                            },
                            {
                                text: "äººå·¥çŸ¥èƒ½ã®ç™ºé”ã«ã‚ˆã‚Šã€å¾“æ¥äººé–“ãŒè¡Œã£ã¦ã„ãŸå¤šãã®æ¥­å‹™ãŒè‡ªå‹•åŒ–ã•ã‚Œã¤ã¤ã‚ã‚‹ã€‚ã“ã®å¤‰åŒ–ã¯åŠ¹ç‡æ€§ã®å‘ä¸Šã‚’ã‚‚ãŸã‚‰ã™ä¸€æ–¹ã§ã€é›‡ç”¨ã¸ã®å½±éŸ¿ã¨ã„ã†æ–°ãŸãªèª²é¡Œã‚’ç”Ÿã¿å‡ºã—ã¦ã„ã‚‹ã€‚",
                                question: "äººå·¥çŸ¥èƒ½ã®ç™ºé”ãŒã‚‚ãŸã‚‰ã™å½±éŸ¿ã¨ã—ã¦è¿°ã¹ã‚‰ã‚Œã¦ã„ãªã„ã‚‚ã®ã¯ã©ã‚Œã‹ã€‚",
                                choices: ["æ¥­å‹™ã®è‡ªå‹•åŒ–", "åŠ¹ç‡æ€§ã®å‘ä¸Š", "é›‡ç”¨ã¸ã®ì˜í–¥", "êµìœ¡ã‚·ã‚¹ãƒ†ãƒ ã®æ”¹é©"],
                                correct: 3
                            }
                        ];
                        
                        const selectedPassage = passages[Math.floor(Math.random() * passages.length)];
                        generatedProblem = {
                            passage: selectedPassage.text,
                            question: selectedPassage.question,
                            choices: selectedPassage.choices,
                            correct: selectedPassage.correct,
                            explanation: "ì§€ë¬¸ì˜ ë‚´ìš©ì„ ì •í™•íˆ íŒŒì•…í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤."
                        };
                    }

                    const problemWithMeta = {
                        ...generatedProblem,
                        type: problemType,
                        id: Date.now(),
                        source: "í…œí”Œë¦¿ ìƒì„±",
                        generatedAt: new Date().toLocaleString()
                    };

                    setGenerationHistory(prev => [problemWithMeta, ...prev.slice(0, 9)]);
                    return problemWithMeta;

                } catch (error) {
                    console.error("í…œí”Œë¦¿ ë¬¸ì œ ìƒì„± ì‹¤íŒ¨:", error);
                    
                    // í…œí”Œë¦¿ë„ ì‹¤íŒ¨í•˜ë©´ ë°±ì—… ë¬¸ì œ ì‚¬ìš© (3ìˆœìœ„)
                    const backupList = backupProblems[problemType];
                    const randomBackup = backupList[Math.floor(Math.random() * backupList.length)];
                    
                    return {
                        ...randomBackup,
                        type: problemType,
                        id: Date.now(),
                        source: "ë¡œì»¬ ë°±ì—… (í…œí”Œë¦¿ ì‹¤íŒ¨)",
                        error: "í…œí”Œë¦¿ ìƒì„± ì‹¤íŒ¨ë¡œ ë°±ì—… ë¬¸ì œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."
                    };
                }
            };

            const generateProblem = async () => {
                let problemType = selectedType;
                if (problemType === 'random') {
                    const types = ['kanji', 'grammar', 'vocabulary', 'reading'];
                    problemType = types[Math.floor(Math.random() * types.length)];
                }

                // ì¼ë‹¨ í…œí”Œë¦¿ ì‹œìŠ¤í…œë§Œ ì‚¬ìš© (CORS ë¬¸ì œ í•´ê²°)
                const newProblem = await generateWithTemplate(problemType);
                setCurrentProblem(newProblem);
                setShowAnswer(false);
            };

            const handleAnswer = (selectedIndex) => {
                if (currentProblem && selectedIndex === currentProblem.correct) {
                    setScore(prev => ({ correct: prev.correct + 1, total: prev.total + 1 }));
                } else {
                    setScore(prev => ({ ...prev, total: prev.total + 1 }));
                }
                setShowAnswer(true);
            };

            const LoaderIcon = () => (
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            );

            return (
                <div className="max-w-4xl mx-auto p-6 bg-white min-h-screen">
                    <div className="text-center mb-8">
                        <h1 className="text-3xl font-bold text-gray-800 mb-2">JLPT N1 AI ë¬¸ì œ ìƒì„±ê¸°</h1>
                        <p className="text-gray-600">Claude AIê°€ ì‹¤ì‹œê°„ìœ¼ë¡œ ìƒˆë¡œìš´ N1 ë¬¸ì œë¥¼ ìƒì„±í•©ë‹ˆë‹¤!</p>
                    </div>

                    {/* ì ìˆ˜ ë° ìƒíƒœ í‘œì‹œ */}
                    <div className="grid md:grid-cols-2 gap-4 mb-6">
                        <div className="bg-blue-50 p-4 rounded-lg text-center">
                            <div className="text-lg font-semibold text-blue-800">
                                ì •ë‹µë¥ : {score.total > 0 ? Math.round((score.correct / score.total) * 100) : 0}% 
                                ({score.correct}/{score.total})
                            </div>
                        </div>
                        <div className="bg-green-50 p-4 rounded-lg text-center">
                            <div className="text-lg font-semibold text-green-800">
                                ìƒì„±ëœ ë¬¸ì œ: {generationHistory.length}ê°œ
                            </div>
                        </div>
                    </div>

                    {/* ë¬¸ì œ ìœ í˜• ì„ íƒ */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold mb-3">ë¬¸ì œ ìœ í˜• ì„ íƒ</h3>
                        <div className="flex flex-wrap gap-2">
                            {[
                                { value: 'random', label: 'ëœë¤' },
                                { value: 'kanji', label: 'í•œì ì½ê¸°' },
                                { value: 'grammar', label: 'ë¬¸ë²•' },
                                { value: 'vocabulary', label: 'ì–´íœ˜' },
                                { value: 'reading', label: 'ë…í•´' }
                            ].map((type) => (
                                <button
                                    key={type.value}
                                    onClick={() => setSelectedType(type.value)}
                                    className={`px-4 py-2 rounded-lg transition-colors ${
                                        selectedType === type.value
                                            ? 'bg-blue-500 text-white'
                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                    }`}
                                >
                                    {type.label}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* ë¬¸ì œ ìƒì„± ë²„íŠ¼ */}
                    <div className="text-center mb-8">
                        <button
                            onClick={generateProblem}
                            disabled={isGenerating}
                            className="bg-green-500 hover:bg-green-600 disabled:bg-gray-400 text-white px-8 py-3 rounded-lg text-lg font-semibold transition-colors flex items-center gap-2 mx-auto"
                        >
                            {isGenerating ? (
                                <>
                                    <LoaderIcon />
                                    AIê°€ ë¬¸ì œ ìƒì„± ì¤‘...
                                </>
                            ) : (
                                <>
                                    ğŸš€ ìƒˆ ë¬¸ì œ ìƒì„± (AI)
                                </>
                            )}
                        </button>
                        {isGenerating && (
                            <p className="text-sm text-gray-600 mt-2">
                                Claude AIê°€ ë§ì¶¤í˜• N1 ë¬¸ì œë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...
                            </p>
                        )}
                    </div>

                    {/* ë¬¸ì œ í‘œì‹œ */}
                    {currentProblem && (
                        <div className="bg-gray-50 p-6 rounded-lg mb-6">
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="text-lg font-semibold">
                                    {currentProblem.type === 'kanji' ? 'í•œì ì½ê¸°' : 
                                     currentProblem.type === 'grammar' ? 'ë¬¸ë²•' :
                                     currentProblem.type === 'vocabulary' ? 'ì–´íœ˜' : 'ë…í•´'} ë¬¸ì œ
                                </h3>
                                <div className="text-sm text-gray-500">
                                    {currentProblem.source} {currentProblem.generatedAt && `| ${currentProblem.generatedAt}`}
                                </div>
                            </div>

                            {currentProblem.error && (
                                <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded text-yellow-800">
                                    âš ï¸ {currentProblem.error}
                                </div>
                            )}

                            {currentProblem.type === 'reading' && (
                                <div className="mb-4 p-4 bg-white rounded border">
                                    <p className="text-gray-800 leading-relaxed">{currentProblem.passage}</p>
                                </div>
                            )}

                            <div className="mb-4">
                                <p className="text-lg mb-4">
                                    {currentProblem.type === 'kanji' ? (
                                        <>
                                            ë‹¤ìŒ ë¬¸ì¥ì˜ ë°‘ì¤„ ì¹œ ë¶€ë¶„ì˜ ì½ê¸°ë¡œ ê°€ì¥ ì ì ˆí•œ ê²ƒì„ ê³ ë¥´ì‹œì˜¤.<br />
                                            <span className="font-bold text-xl mt-2 block">
                                                {currentProblem.question?.replace('**' + currentProblem.underlined + '**', 
                                                    `__${currentProblem.underlined}__`)}
                                            </span>
                                        </>
                                    ) : currentProblem.type === 'reading' ? (
                                        <span className="font-bold">{currentProblem.question}</span>
                                    ) : (
                                        <>
                                            ë‹¤ìŒ ë¬¸ì¥ì˜ (ã€€)ì— ë“¤ì–´ê°ˆ ê°€ì¥ ì ì ˆí•œ ê²ƒì„ ê³ ë¥´ì‹œì˜¤.<br />
                                            <span className="font-bold text-xl mt-2 block">{currentProblem.question}</span>
                                        </>
                                    )}
                                </p>
                            </div>

                            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                                {currentProblem.choices?.map((choice, index) => (
                                    <button
                                        key={index}
                                        onClick={() => handleAnswer(index)}
                                        disabled={showAnswer}
                                        className={`p-3 text-left rounded border transition-colors ${
                                            showAnswer
                                                ? index === currentProblem.correct
                                                    ? 'bg-green-100 border-green-500 text-green-800'
                                                    : 'bg-gray-100 border-gray-300 text-gray-600'
                                                : 'bg-white border-gray-300 hover:bg-blue-50 hover:border-blue-300'
                                        }`}
                                    >
                                        <span className="font-semibold">{index + 1}. </span>
                                        {choice}
                                    </button>
                                ))}
                            </div>

                            {showAnswer && (
                                <div className="mt-4 p-4 bg-blue-50 border border-blue-200 rounded">
                                    <p className="font-semibold text-blue-800 mb-2">
                                        ì •ë‹µ: {currentProblem.correct + 1}ë²ˆ
                                    </p>
                                    <p className="text-blue-700">{currentProblem.explanation}</p>
                                </div>
                            )}
                        </div>
                    )}

                    {/* ì•ˆë‚´ ë©”ì‹œì§€ */}
                    {!currentProblem && (
                        <div className="text-center text-gray-500 mt-12">
                            <p className="text-lg">ìœ„ì˜ "ìƒˆ ë¬¸ì œ ìƒì„±" ë²„íŠ¼ì„ í´ë¦­í•´ì„œ ì‹œì‘í•˜ì„¸ìš”!</p>
                            <p className="text-sm mt-2">Claude AI â†’ í…œí”Œë¦¿ â†’ ë°±ì—… ìˆœì„œë¡œ ìµœê³  í’ˆì§ˆì˜ ë¬¸ì œë¥¼ ì œê³µí•©ë‹ˆë‹¤.</p>
                        </div>
                    )}

                    {/* ìƒì„± ê¸°ë¡ */}
                    {generationHistory.length > 0 && (
                        <div className="bg-gray-50 p-5 rounded-lg mt-6">
                            <h3 className="font-bold text-lg mb-3 text-gray-800">ìµœê·¼ ìƒì„±ëœ ë¬¸ì œë“¤</h3>
                            <div className="space-y-2 max-h-60 overflow-y-auto">
                                {generationHistory.map((problem, index) => (
                                    <div key={problem.id} className="flex items-center justify-between bg-white p-3 rounded border">
                                        <div className="flex items-center gap-2">
                                            <span className="font-medium">
                                                {problem.type === 'kanji' ? 'í•œì' : 
                                                 problem.type === 'grammar' ? 'ë¬¸ë²•' :
                                                 problem.type === 'vocabulary' ? 'ì–´íœ˜' : 'ë…í•´'}
                                            </span>
                                            <span className="text-sm text-gray-500">#{index + 1}</span>
                                        </div>
                                        <div className="text-sm text-gray-500">
                                            {problem.source} | {problem.generatedAt}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<JLPTGenerator />, document.getElementById('root'));
    </script>
</body>
</html>
