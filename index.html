<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JLPT N1 AI 문제 생성기</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3B82F6">
    <link rel="apple-touch-icon" href="icon-192.png">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState } = React;

        const JLPTGenerator = () => {
            const [currentProblem, setCurrentProblem] = useState(null);
            const [selectedType, setSelectedType] = useState('random');
            const [showAnswer, setShowAnswer] = useState(false);
            const [score, setScore] = useState({ correct: 0, total: 0 });
            const [isGenerating, setIsGenerating] = useState(false);
            const [generationHistory, setGenerationHistory] = useState([]);

            // 백업용 로컬 문제 (최종 백업)
            const backupProblems = {
                kanji: [
                    {
                        question: "この地域は**豊穣**な土地として知られている。",
                        underlined: "豊穣",
                        choices: ["ほうじょう", "ほうろう", "ぽうじょう", "ぼうじょう"],
                        correct: 0,
                        explanation: "豊穣（ほうじょう）= 풍요로운, 비옥한",
                        source: "로컬"
                    },
                    {
                        question: "彼の**洞察力**には驚かされる。",
                        underlined: "洞察力",
                        choices: ["どうさつりょく", "とうさつりょく", "どうせつりょく", "とうせつりょく"],
                        correct: 0,
                        explanation: "洞察力（どうさつりょく）= 통찰력",
                        source: "로컬"
                    }
                ],
                grammar: [
                    {
                        question: "彼は忙しい（　）、毎日勉強を続けている。",
                        choices: ["にもかかわらず", "によって", "において", "に対して"],
                        correct: 0,
                        explanation: "にもかかわらず = ~에도 불구하고",
                        source: "로컬"
                    },
                    {
                        question: "この計画は費用（　）問題がある。",
                        choices: ["にとって", "の点で", "として", "によって"],
                        correct: 1,
                        explanation: "~の点で = ~의 면에서, ~에 관해서",
                        source: "로컬"
                    }
                ],
                vocabulary: [
                    {
                        question: "新しいシステムの（　）を図るため、研修を行う。",
                        choices: ["浸透", "沈殿", "浸水", "沈没"],
                        correct: 0,
                        explanation: "浸透（しんとう）= 침투, 보급",
                        source: "로컬"
                    },
                    {
                        question: "この問題の（　）を明らかにする必要がある。",
                        choices: ["要因", "要員", "用人", "要人"],
                        correct: 0,
                        explanation: "要因（よういん）= 요인, 원인",
                        source: "로컬"
                    }
                ],
                reading: [
                    {
                        passage: "現代社会における技術革新の速度は加速度的に増している。特にAI技術の発達により、従来人間が行っていた業務の多くが自動化されつつある。",
                        question: "この文章の主要なテーマは何か。",
                        choices: ["AI技術の歴史について", "技術革新による変化とその影響", "雇용問題の解決책", "효율성向상の方法"],
                        correct: 1,
                        explanation: "기술혁신이 가져오는 변화와 그 영향에 대해 논하고 있음",
                        source: "로컬"
                    }
                ]
            };

            // 백엔드 API 호출로 새 문제 생성 (1순위)
            const generateWithAPI = async (problemType) => {
                setIsGenerating(true);
                
                try {
                    const response = await fetch('/api/generate-problem', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ problemType })
                    });

                    if (!response.ok) {
                        throw new Error(`API 호출 실패: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    const problemWithMeta = {
                        ...data.problem,
                        id: Date.now(),
                        generatedAt: new Date().toLocaleString()
                    };

                    setGenerationHistory(prev => [problemWithMeta, ...prev.slice(0, 9)]);
                    return problemWithMeta;

                } catch (error) {
                    console.error("백엔드 API 호출 실패:", error);
                    
                    // API 실패 시 템플릿 시스템으로 대체
                    return await generateWithTemplate(problemType);
                } finally {
                    setIsGenerating(false);
                }
            };

            // 템플릿 기반 문제 생성 (2순위 백업)
            const generateWithTemplate = async (problemType) => {
                // 템플릿 기반 문제 데이터
                const problemTemplates = {
                    kanji: {
                        templates: [
                            { sentence: "この{context}は{adjective}として知られている。", contexts: ["地域", "技術", "方法", "企業", "制度"], adjectives: ["豊穣", "革新的", "効率的", "先進的", "画期的"] },
                            { sentence: "彼の{skill}には{feeling}。", contexts: ["技能", "能力", "才能", "実力", "手腕"], adjectives: ["驚嘆", "感心", "敬服", "称賛", "感動"] },
                            { sentence: "この{object}の{quality}は{level}だ。", contexts: ["製品", "サービス", "技術", "システム", "方法"], adjectives: ["品質", "性能", "精度", "効率", "安全性"] }
                        ],
                        words: [
                            { word: "豊穣", reading: "ほうじょう", wrongReadings: ["ほうろう", "ぽうじょう", "ぼうじょう"], meaning: "풍요로운, 비옥한" },
                            { word: "洞察力", reading: "どうさつりょく", wrongReadings: ["とうさつりょく", "どうせつりょく", "とうせつりょく"], meaning: "통찰력" },
                            { word: "根本的", reading: "こんぽんてき", wrongReadings: ["ねもとてき", "こんもとてき", "ねほんてき"], meaning: "근본적인" },
                            { word: "画期的", reading: "かっきてき", wrongReadings: ["がきてき", "がっきてき", "かきてき"], meaning: "획기적인" },
                            { word: "低迷", reading: "ていめい", wrongReadings: ["ていまい", "ていび", "ていい"], meaning: "침체, 부진" },
                            { word: "顕著", reading: "けんちょ", wrongReadings: ["けんしょ", "げんちょ", "げんしょ"], meaning: "현저한, 뚜렷한" },
                            { word: "潜在", reading: "せんざい", wrongReadings: ["せんたい", "ぜんざい", "ぜんたい"], meaning: "잠재적인" },
                            { word: "慢性", reading: "まんせい", wrongReadings: ["ばんせい", "まんしょう", "ばんしょう"], meaning: "만성적인" }
                        ]
                    },
                    grammar: [
                        { pattern: "にもかかわらず", meaning: "~에도 불구하고", examples: ["雨", "忙しい", "反対", "困難"], contexts: ["試合は行われた", "勉強を続けた", "計画を実行した", "成功した"] },
                        { pattern: "のわりに", meaning: "~에 비해, ~치고는", examples: ["若い", "安い", "簡単", "短時間"], contexts: ["しっかりしている", "品質が良い", "難しく感じる", "多くのことを学んだ"] },
                        { pattern: "に基づいて", meaning: "~에 기초하여", examples: ["事実", "データ", "経験", "理論"], contexts: ["判断する", "計画を立てる", "決定する", "分析する"] },
                        { pattern: "を限りに", meaning: "~을 마지막으로", examples: ["今日", "今年", "この仕事", "今回"], contexts: ["辞める", "終了する", "引退する", "最後にする"] },
                        { pattern: "の点で", meaning: "~의 면에서", examples: ["安全性", "効率", "コスト", "品質"], contexts: ["問題がある", "優れている", "改善が必要", "満足している"] },
                        { pattern: "に際して", meaning: "~에 즈음하여", examples: ["卒業", "開業", "結婚", "転職"], contexts: ["挨拶をする", "準備をする", "祝福を受ける", "決意を新たにする"] }
                    ],
                    vocabulary: [
                        { word: "浸透", wrongWords: ["沈殿", "浸水", "沈没"], meaning: "침투, 보급", contexts: ["新しいシステムの{word}を図るため、研修を行う。"] },
                        { word: "要因", wrongWords: ["要員", "用人", "要人"], meaning: "요인, 원인", contexts: ["この問題の{word}を明らかにする必要がある。"] },
                        { word: "検討", wrongWords: ["見当", "健闘", "検疫"], meaning: "검토", contexts: ["彼の提案は{word}に値する。"] },
                        { word: "精度", wrongWords: ["正確度", "精密度", "清度"], meaning: "정밀도", contexts: ["この技術の{word}には驚いた。"] },
                        { word: "関心", wrongWords: ["観心", "感心", "歓心"], meaning: "관심", contexts: ["環境問題への{word}が高まっている。"] },
                        { word: "促進", wrongWords: ["即進", "足進", "側進"], meaning: "촉진", contexts: ["経済発展の{word}が急務だ。"] },
                        { word: "懸念", wrongWords: ["県念", "賢念", "堅念"], meaning: "우려", contexts: ["安全性への{word}が高まっている。"] }
                    ]
                };

                try {
                    await new Promise(resolve => setTimeout(resolve, 800)); // 로딩 효과

                    let generatedProblem;

                    if (problemType === 'kanji') {
                        const template = problemTemplates.kanji.templates[Math.floor(Math.random() * problemTemplates.kanji.templates.length)];
                        const targetWord = problemTemplates.kanji.words[Math.floor(Math.random() * problemTemplates.kanji.words.length)];
                        const context = template.contexts[Math.floor(Math.random() * template.contexts.length)];
                        const adjective = template.adjectives[Math.floor(Math.random() * template.adjectives.length)];
                        
                        let sentence = template.sentence.replace('{context}', context).replace('{adjective}', adjective);
                        sentence = sentence.replace(adjective, targetWord.word);
                        
                        const allChoices = [targetWord.reading, ...targetWord.wrongReadings].sort(() => Math.random() - 0.5);
                        
                        generatedProblem = {
                            question: sentence.replace(targetWord.word, `**${targetWord.word}**`),
                            underlined: targetWord.word,
                            choices: allChoices,
                            correct: allChoices.indexOf(targetWord.reading),
                            explanation: `${targetWord.word}（${targetWord.reading}）= ${targetWord.meaning}`
                        };
                    } else if (problemType === 'grammar') {
                        const grammarItem = problemTemplates.grammar[Math.floor(Math.random() * problemTemplates.grammar.length)];
                        const example = grammarItem.examples[Math.floor(Math.random() * grammarItem.examples.length)];
                        const context = grammarItem.contexts[Math.floor(Math.random() * grammarItem.contexts.length)];
                        
                        const wrongPatterns = problemTemplates.grammar
                            .filter(g => g.pattern !== grammarItem.pattern)
                            .map(g => g.pattern)
                            .slice(0, 3);
                        
                        const allChoices = [grammarItem.pattern, ...wrongPatterns].sort(() => Math.random() - 0.5);
                        
                        generatedProblem = {
                            question: `${example}（　）、${context}。`,
                            choices: allChoices,
                            correct: allChoices.indexOf(grammarItem.pattern),
                            explanation: `${grammarItem.pattern} = ${grammarItem.meaning}`
                        };
                    } else if (problemType === 'vocabulary') {
                        const vocabItem = problemTemplates.vocabulary[Math.floor(Math.random() * problemTemplates.vocabulary.length)];
                        const context = vocabItem.contexts[Math.floor(Math.random() * vocabItem.contexts.length)];
                        const allChoices = [vocabItem.word, ...vocabItem.wrongWords].sort(() => Math.random() - 0.5);
                        
                        generatedProblem = {
                            question: context.replace('{word}', '（　）'),
                            choices: allChoices,
                            correct: allChoices.indexOf(vocabItem.word),
                            explanation: `${vocabItem.word} = ${vocabItem.meaning}`
                        };
                    } else { // reading
                        const passages = [
                            {
                                text: "現代社会において、持続可能な発展が重要視されている。環境保護と経済成長の両立は困難な課題だが、技術革新により解決の糸口が見えてきた。",
                                question: "この文章で述べられている主な内容は何か。",
                                choices: ["環境保護の重要性", "持続可能な発展の課題と可能性", "技術革新の限界", "경제成長의 문제점"],
                                correct: 1
                            },
                            {
                                text: "人工知能の発達により、従来人間が行っていた多くの業務が自動化されつつある。この変化は効率性の向上をもたらす一方で、雇用への影響という新たな課題を生み出している。",
                                question: "人工知能の発達がもたらす影響として述べられていないものはどれか。",
                                choices: ["業務の自動化", "効率性の向上", "雇用への영향", "교육システムの改革"],
                                correct: 3
                            }
                        ];
                        
                        const selectedPassage = passages[Math.floor(Math.random() * passages.length)];
                        generatedProblem = {
                            passage: selectedPassage.text,
                            question: selectedPassage.question,
                            choices: selectedPassage.choices,
                            correct: selectedPassage.correct,
                            explanation: "지문의 내용을 정확히 파악하는 것이 중요합니다."
                        };
                    }

                    const problemWithMeta = {
                        ...generatedProblem,
                        type: problemType,
                        id: Date.now(),
                        source: "템플릿 생성",
                        generatedAt: new Date().toLocaleString()
                    };

                    setGenerationHistory(prev => [problemWithMeta, ...prev.slice(0, 9)]);
                    return problemWithMeta;

                } catch (error) {
                    console.error("템플릿 문제 생성 실패:", error);
                    
                    // 템플릿도 실패하면 백업 문제 사용 (3순위)
                    const backupList = backupProblems[problemType];
                    const randomBackup = backupList[Math.floor(Math.random() * backupList.length)];
                    
                    return {
                        ...randomBackup,
                        type: problemType,
                        id: Date.now(),
                        source: "로컬 백업 (템플릿 실패)",
                        error: "템플릿 생성 실패로 백업 문제를 사용합니다."
                    };
                }
            };

            const generateProblem = async () => {
                let problemType = selectedType;
                if (problemType === 'random') {
                    const types = ['kanji', 'grammar', 'vocabulary', 'reading'];
                    problemType = types[Math.floor(Math.random() * types.length)];
                }

                // 일단 템플릿 시스템만 사용 (CORS 문제 해결)
                const newProblem = await generateWithTemplate(problemType);
                setCurrentProblem(newProblem);
                setShowAnswer(false);
            };

            const handleAnswer = (selectedIndex) => {
                if (currentProblem && selectedIndex === currentProblem.correct) {
                    setScore(prev => ({ correct: prev.correct + 1, total: prev.total + 1 }));
                } else {
                    setScore(prev => ({ ...prev, total: prev.total + 1 }));
                }
                setShowAnswer(true);
            };

            const LoaderIcon = () => (
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            );

            return (
                <div className="max-w-4xl mx-auto p-6 bg-white min-h-screen">
                    <div className="text-center mb-8">
                        <h1 className="text-3xl font-bold text-gray-800 mb-2">JLPT N1 AI 문제 생성기</h1>
                        <p className="text-gray-600">Claude AI가 실시간으로 새로운 N1 문제를 생성합니다!</p>
                    </div>

                    {/* 점수 및 상태 표시 */}
                    <div className="grid md:grid-cols-2 gap-4 mb-6">
                        <div className="bg-blue-50 p-4 rounded-lg text-center">
                            <div className="text-lg font-semibold text-blue-800">
                                정답률: {score.total > 0 ? Math.round((score.correct / score.total) * 100) : 0}% 
                                ({score.correct}/{score.total})
                            </div>
                        </div>
                        <div className="bg-green-50 p-4 rounded-lg text-center">
                            <div className="text-lg font-semibold text-green-800">
                                생성된 문제: {generationHistory.length}개
                            </div>
                        </div>
                    </div>

                    {/* 문제 유형 선택 */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold mb-3">문제 유형 선택</h3>
                        <div className="flex flex-wrap gap-2">
                            {[
                                { value: 'random', label: '랜덤' },
                                { value: 'kanji', label: '한자 읽기' },
                                { value: 'grammar', label: '문법' },
                                { value: 'vocabulary', label: '어휘' },
                                { value: 'reading', label: '독해' }
                            ].map((type) => (
                                <button
                                    key={type.value}
                                    onClick={() => setSelectedType(type.value)}
                                    className={`px-4 py-2 rounded-lg transition-colors ${
                                        selectedType === type.value
                                            ? 'bg-blue-500 text-white'
                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                    }`}
                                >
                                    {type.label}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* 문제 생성 버튼 */}
                    <div className="text-center mb-8">
                        <button
                            onClick={generateProblem}
                            disabled={isGenerating}
                            className="bg-green-500 hover:bg-green-600 disabled:bg-gray-400 text-white px-8 py-3 rounded-lg text-lg font-semibold transition-colors flex items-center gap-2 mx-auto"
                        >
                            {isGenerating ? (
                                <>
                                    <LoaderIcon />
                                    AI가 문제 생성 중...
                                </>
                            ) : (
                                <>
                                    🚀 새 문제 생성 (AI)
                                </>
                            )}
                        </button>
                        {isGenerating && (
                            <p className="text-sm text-gray-600 mt-2">
                                Claude AI가 맞춤형 N1 문제를 생성하고 있습니다. 잠시만 기다려주세요...
                            </p>
                        )}
                    </div>

                    {/* 문제 표시 */}
                    {currentProblem && (
                        <div className="bg-gray-50 p-6 rounded-lg mb-6">
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="text-lg font-semibold">
                                    {currentProblem.type === 'kanji' ? '한자 읽기' : 
                                     currentProblem.type === 'grammar' ? '문법' :
                                     currentProblem.type === 'vocabulary' ? '어휘' : '독해'} 문제
                                </h3>
                                <div className="text-sm text-gray-500">
                                    {currentProblem.source} {currentProblem.generatedAt && `| ${currentProblem.generatedAt}`}
                                </div>
                            </div>

                            {currentProblem.error && (
                                <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded text-yellow-800">
                                    ⚠️ {currentProblem.error}
                                </div>
                            )}

                            {currentProblem.type === 'reading' && (
                                <div className="mb-4 p-4 bg-white rounded border">
                                    <p className="text-gray-800 leading-relaxed">{currentProblem.passage}</p>
                                </div>
                            )}

                            <div className="mb-4">
                                <p className="text-lg mb-4">
                                    {currentProblem.type === 'kanji' ? (
                                        <>
                                            다음 문장의 밑줄 친 부분의 읽기로 가장 적절한 것을 고르시오.<br />
                                            <span className="font-bold text-xl mt-2 block">
                                                {currentProblem.question?.replace('**' + currentProblem.underlined + '**', 
                                                    `__${currentProblem.underlined}__`)}
                                            </span>
                                        </>
                                    ) : currentProblem.type === 'reading' ? (
                                        <span className="font-bold">{currentProblem.question}</span>
                                    ) : (
                                        <>
                                            다음 문장의 (　)에 들어갈 가장 적절한 것을 고르시오.<br />
                                            <span className="font-bold text-xl mt-2 block">{currentProblem.question}</span>
                                        </>
                                    )}
                                </p>
                            </div>

                            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                                {currentProblem.choices?.map((choice, index) => (
                                    <button
                                        key={index}
                                        onClick={() => handleAnswer(index)}
                                        disabled={showAnswer}
                                        className={`p-3 text-left rounded border transition-colors ${
                                            showAnswer
                                                ? index === currentProblem.correct
                                                    ? 'bg-green-100 border-green-500 text-green-800'
                                                    : 'bg-gray-100 border-gray-300 text-gray-600'
                                                : 'bg-white border-gray-300 hover:bg-blue-50 hover:border-blue-300'
                                        }`}
                                    >
                                        <span className="font-semibold">{index + 1}. </span>
                                        {choice}
                                    </button>
                                ))}
                            </div>

                            {showAnswer && (
                                <div className="mt-4 p-4 bg-blue-50 border border-blue-200 rounded">
                                    <p className="font-semibold text-blue-800 mb-2">
                                        정답: {currentProblem.correct + 1}번
                                    </p>
                                    <p className="text-blue-700">{currentProblem.explanation}</p>
                                </div>
                            )}
                        </div>
                    )}

                    {/* 안내 메시지 */}
                    {!currentProblem && (
                        <div className="text-center text-gray-500 mt-12">
                            <p className="text-lg">위의 "새 문제 생성" 버튼을 클릭해서 시작하세요!</p>
                            <p className="text-sm mt-2">Claude AI → 템플릿 → 백업 순서로 최고 품질의 문제를 제공합니다.</p>
                        </div>
                    )}

                    {/* 생성 기록 */}
                    {generationHistory.length > 0 && (
                        <div className="bg-gray-50 p-5 rounded-lg mt-6">
                            <h3 className="font-bold text-lg mb-3 text-gray-800">최근 생성된 문제들</h3>
                            <div className="space-y-2 max-h-60 overflow-y-auto">
                                {generationHistory.map((problem, index) => (
                                    <div key={problem.id} className="flex items-center justify-between bg-white p-3 rounded border">
                                        <div className="flex items-center gap-2">
                                            <span className="font-medium">
                                                {problem.type === 'kanji' ? '한자' : 
                                                 problem.type === 'grammar' ? '문법' :
                                                 problem.type === 'vocabulary' ? '어휘' : '독해'}
                                            </span>
                                            <span className="text-sm text-gray-500">#{index + 1}</span>
                                        </div>
                                        <div className="text-sm text-gray-500">
                                            {problem.source} | {problem.generatedAt}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<JLPTGenerator />, document.getElementById('root'));
    </script>
</body>
</html>
